---
layout: post
title: 5G 信道编码流程介绍
categories: [通信, 信道编码]
description: 5G 信道编码
keywords: 通信, 信道编码
mermaid: false
sequence: false
flow: false
mathjax: true
mindmap: false
mindmap2: false
---

## 一、引言：5G 信道编码概述

在4G LTE中，Turbo编码作为核心信道编码方案，凭借其强大的纠错性能和实现成熟度，在多种传输场景中得到了广泛应用。

在5G中，**LDPC**（低密度奇偶校验码） 被引入作为数据信道的主要信道编码方式，取代了LTE中的Turbo码。

本节将系统介绍5G NR中LDPC编码流程，包括传**输块CRC附加**、**基图选择与段划分**、**码字生成**、**速率匹配及码块级联**等关键步骤。

## 二、5G下行信道编码流程总体介绍

5G NR 的下行共享信道（PDSCH）信道编码流程总体与4G系统类似，包括以下步骤：

- 传输块CRC附加：为每个传输块添加24比特的CRC，用于差错检测（见 38.212 - 7.2.1）；

- LDPC基图选择：根据传输块大小和调制方式选择LDPC基图（Base Graph 1 或 2），为后续编码提供结构依据（见 7.2.2）；

- 码块分段与子块CRC附加：当传输块过大时将其分段，并对每个码块附加CRC（见 7.2.3）；

- 信道编码：使用LDPC编码对每个码块进行独立编码，提升纠错能力（见 7.2.4）；

- 速率匹配：通过比特选择、交织和重复/裁剪等操作使输出比特数适应物理层资源分配（见 7.2.5）。

## 三、传输块级 CRC 添加（Transport Block CRC Attachment）

同4G，TB级CRC附加（Transport Block CRC Attachment）用于对每个**传输块**（Transport Block）提供**整体错误检测能力**，确保数据传输的完整性。

参考 [TS 38.212 第7.2.1节 和 第5.1节]

映射顺序采用最高有效位优先（MSB），即按大端序排列。

**选择规则如下：**

根据传输块长度 𝐴（比特），选择CRC多项式长度：

- 长块（A > 3824）： 使用24比特CRC，多项式为 CRC24A(D)

$$
g_{\text {CRC } 24 \mathrm{~A}}(D)=D^{24}+D^{23}+D^{18}+D^{17}+D^{14}+D^{11}+D^{10}+D^7+D^6+D^5+D^4+D^3+D+1
$$

- 短块（A ≤ 3824）： 使用16比特CRC，多项式为 CRC16(D)

$$
g_{\mathrm{CRC} 16}(D)=\left[D^{16}+D^{12}+D^5+1\right]
$$

**编码过程：**

- 输入比特序列:

$$
a_0, a_1, \ldots, a_{A-1}
$$

- 在有限域 GF(2) 上，按照系统形式进行CRC编码:
  - 输入序列与多项式整除，余数作为CRC附加至原始数据尾部

输出最终比特序列:

$$
b_0, b_1, \ldots, b_{B-1}
$$

其中：

$$
B = A + L
$$

L 位CRC长度。

**总之5G中TB级CRC附加机制与LTE几乎完全一致，本质上均为在GF(2)域进行多项式除法运算。**

## 四、LDPC基图的选择

参考TS 38.212 7.2.2

在5G NR中，LDPC信道编码使用**两种基础母矩阵**（Base Graph）结构，分别称为**基图1**和**基图2**。

为了在不同数据量和场景下实现性能与复杂度的权衡，5G标准根据**有效载荷大小A**（即传输比特长度）和**编码速率R**的组合来选择合适的基图：

基图的选择规则为：

$$
\text { 基图 }= \begin{cases}2, & \text { 当 } A \leq 292, \text { 或 }(A \leq 3824 \text { 且 } R \leq 0.67), \text { 或 } R \leq 0.25 \\ 1, & \text { 否则 }\end{cases}
$$

其中：

- A：原始传输块长度；
- R：编码速率
- 基图1和基图2对应不同结构和稀疏程度的校验矩阵

**性能与效率权衡**：

- **基图1**：适用于**高码率**、**大数据块**场景，编码效率高
- **基图2**：适用于**低码率**、**小数据块**或高可靠性需求场景

## 五、码块分割与子块CRC附加

参考 3GPP TS 38.212 5.2.2

码块分割与子块CRC附加”阶段的主要目标是将整个**传输块**（Transport Block）划分为多个**更小的码块**（Code Block）并为每个码块分别**添加CRC校验**。

![码块分割](/images/2025-07-28-5G信道编码/码块分割.jpg)

### 1. 输入输出

- 输入：添加过TB CRC的完整比特流

$$
\left\{b_0, b_1, \ldots, b_{B-1}\right\}
$$

长度 B=A+24

- 输出：生成 𝐶 个码块

$$
\left\{c_{r, 0}, c_{r, 1}, \ldots, c_{r,\left(K_r-1\right)}\right\}
$$

每个码块附加24比特子块CRC校验。

### 2. 最大码块长度 Kcb 的确定

LDPC编码器根据所选的基图（Base Graph）决定码块最大长度 𝐾𝑐𝑏

- 基图1：最大码块长度为 8448；
- 基图2：最大码块长度为 3840；

根据 𝐾𝑐𝑏 的大小判断是否需要码块分割。若传输块长度 𝐵>𝐾𝑐𝑏 ，则进行分割；否则直接进入编码阶段。

### 3. 码块数量计算

**目前已知输入：**

- 已添加 TB CRC 的传输块比特流，长度为 B；
- 当前选定的最大码块长度 𝐾𝑐𝑏（由所选基图决定）；

📌 分两种情况处理：

**case1：单码块场景（不分段）**

$$
B \leq K_{c b}
$$

- 无需拆分，设置码块数量为 𝐶=1；
- **不再添加码块级 CRC**
- 输出总长度不变：𝐵′=𝐵；

**case1：多码块场景（需分段）**

$$
B>K_{c b}
$$

- 需将传输块拆分成**多个码块**，每个码块长度最多为 𝐾𝑐𝑏−𝐿，其中 𝐿=24 是每个码块附加的 CRC 长度；
- 码块数量计算为：

$$
C=\left\lceil\frac{B}{K_{c b}-L}\right\rceil
$$

- 每个码块附加 24 比特 CRC，总输出长度更新为：

$$
B^{\prime}=B+C \cdot L
$$

该步骤确保每个码块不会超过 LDPC 编码器的最大处理能力，并为每个独立的码块单独添加 CRC 校验

### 4. 提升因子与码块长度计算

参考 3GPP TS 38.212 5.2.2

在 5G LDPC 编码中，为了确定最终的码块长度及编码矩阵结构，还需引入**提升因子**（Lifting Size）𝑍𝑐 ，用于生成 LDPC 码的实际结构。

✅ 第一步：确定基图类型对应的最小提升因子下界 𝐾𝑏

- 基图 1 固定为：

$$
K_b=22
$$

- 基图 2 根据输入长度 𝐵 动态选择：

$$
K_b= \begin{cases}10, & B>640 \\ 9, & 560<B \leq 640 \\ 8, & 192<B \leq 560 \\ 6, & B \leq 192\end{cases}
$$

✅ 第二步：计算每个码块的目标编码长度（不含填充）

设总输出长度为 𝐵′，码块数量为 𝐶，则每个码块需编码的目标长度为：

$$
K^{\prime}=\left\lceil\frac{B^{\prime}}{C}\right\rceil
$$

✅ 第三步：从标准中选择合适的提升因子 𝑍𝑐

- 提升因子需满足：

$$
K_b \cdot Z_c \geq K^{\prime}
$$

- 从标准表（如 Table 5.3.2-1）中选择满足条件的**最小** 𝑍𝑐；
  
![ZC提升值](/images/2025-07-28-5G信道编码/ZC提升值.jpg)

✅ 第四步：确定最终编码长度与填充位数

- 最终编码长度为：
  - 基图 1：𝐾=22𝑍𝑐
  - 基图 2：𝐾=10𝑍𝑐

- 若实际比特数小于编码矩阵大小，则需填充：

$$
F=K-K^{\prime}
$$

### 5. 码块分割及码块级CRC添加

- 将**大传输块**拆分为多个适合编码的**码块**；
- **为每个码块添加 CRC 校验位**，提供单独的错误检测能力；
- **填充空白比特位**（Filler Bits），确保码块长度与 LDPC 校验矩阵匹配。

#### (a) 前置条件

- 传输块 TB 已经添加了 TB 级 CRC；
- TB 被分割为 𝐶 个码块；
- 每个码块后续将分别输入 LDPC 编码器。

| 操作             | 内容说明                                          |
| -------------- | --------------------------------------------- |
| **数据分配**       | 将 CRC 后的比特流均匀划分为 $C$ 个码块                      |
| **码块级 CRC 添加** | 若 C > 1，则为每个码块添加 24 位 CRC                   |
| **长度对齐**       | 对不足 LDPC 编码长度的码块添加填充位（Filler Bits），通常填“0”且不发送 |

#### (b) 关键参数梳理

- 输入比特流：原始比特流：

$$
b_0, b_1, \ldots, b_{B^{\prime}-1}
$$

其中 $$B'=B+C\cdot L$$,为添加子块CRC与填充后的总长度；

- 码块数量：𝐶
- 码块长度（不含填充）：𝐾′
- CRC长度：24

#### (c) 具体步骤说明

- 初始化：设置比特计数指针 𝑠=0，用于在原始比特流中按顺序输入数据。

- 循环写入比特流到各码块：

- 添加CRC校验位（当 𝐶>1 时）

- 填充空位（Filler Bits）:对于 𝑘=𝐾′ 到 𝐾−1，将比特填充为 NULL。

✅ **最终输出**

- 𝐶 个码块，每个码块长度均为 𝐾，包含原始数据、CRC及填充位；
- 输出比特流供下一步 LDPC 编码使用:

$$
c_{r, 0}, c_{r, 1}, \ldots, c_{r, K-1}
$$

#### (d) 示例验证

